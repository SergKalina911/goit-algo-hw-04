""" 
                                        Четверте завдання

    Напишіть консольного бота помічника, який розпізнаватиме команди, що вводяться з
клавіатури, та буде відповідати згідно із введеною командою.
    У цій домашній роботі зосередимося на інтерфейсі самого бота. Найпростіший і 
найзручніший на початковому етапі розробки інтерфейс - це консольний застосунок CLI
(Command Line Interface). CLI достатньо просто реалізувати. Будь-який CLI складається з
трьох основних елементів:
    - Парсер команд. Частина, яка відповідає за розбір введених користувачем рядків, 
    виділення з рядка ключових слів та модифікаторів команд.
    - Функції-обробники команд - набір функцій, які ще називають handler, вони відповідають
    за безпосереднє виконання команд.
    - Цикл запит-відповідь. Ця частина застосунку відповідає за отримання від користувача 
    даних та повернення користувачеві відповіді від функції - handler-а.
    На першому етапі наш бот-асистент повинен вміти зберігати ім'я та номер телефону, 
знаходити номер телефону за ім'ям, змінювати записаний номер телефону, виводити в консоль 
всі записи, які зберіг. Щоб реалізувати таку нескладну логіку, скористаємося словником. 
У словнику будемо зберігати ім'я користувача, як ключ, і номер телефону як значення.

                        Вимоги до завдання:

    1. Програма повинна мати функцію main(), яка управляє основним циклом обробки команд.
    2. Реалізуйте функцію parse_input(), яка розбиратиме введений користувачем рядок на 
    команду та її аргументи. Команди та аргументи мають бути розпізнані незалежно від 
    регістру введення.
    3. Ваша програма повинна очікувати на введення команд користувачем та обробляти їх за 
    допомогою відповідних функцій. В разі введення команди "exit" або "close", програма 
    повинна завершувати виконання.
    4. Напишіть функції-обробники для різних команд, наприклад add_contact(), 
    change_contact(), show_phone() тощо.
    5. Використовуйте словник Python для зберігання імен і номерів телефонів. Ім'я буде 
    ключем, а номер телефону – значенням.
    6. Ваша програма має вміти ідентифікувати та повідомляти про неправильно введені команди.

                        Рекомендації для виконання:

    По перше, нам треба систематизувати опис форматів наших команд для консольного 
бота-помічника. Це допоможе зрозуміти які функції треба зробити для кожної команди. 
Виконаймо це:
    1. Команда "hello", тут можна обійтись поки без функції та використати звичайний print:
        - Введення: "hello"
        - Виведення: "How can I help you?"
    2. Команда "add [ім'я] [номер телефону]". Для цієї команди зробимо функцію add_contact:
        - Введення: "add John 1234567890"
        - Виведення: "Contact added."
    3. Команда "change [ім'я] [новий номер телефону]". Для цієї команди зробимо функцію 
    change_contact:
        - Введення: "change John 0987654321"
        - Виведення: "Contact updated." або повідомлення про помилку, якщо ім'я не знайдено
    4. Команда "phone [ім'я]". Для цієї команди зробимо функцію show_phone:
        - Введення: "phone John"
        - Виведення: [номер телефону] або повідомлення про помилку, якщо ім'я не знайдено
    5. Команда "all". Для цієї команди зробимо функцію show_all:
        - Введення: "all"
        - Виведення: усі збережені контакти з номерами телефонів
    6. Команда "close" або "exit". Оскільки тут треба перервати виконання програми, можна 
    поки обійтись без функції для цих команд:
        - Введення: будь-яке з цих слів
        - Виведення: "Good bye!" та завершення роботи бота
    Будь-яка команда, яка не відповідає вищезазначеним форматам, буде вважатися нами 
невірною, і бот буде виводити повідомлення "Invalid command."
    Почнемо з простого варіанту CLI-бота:"""

# def main():
#     print("Welcome to the assistant bot!")
#     while True:
#         command = input("Enter a command: ").strip().lower()

#         if command in ["close", "exit"]:
#             print("Good bye!")
#             break

#         elif command == "hello":
#             print("How can I help you?")
#         else:
#             print("Invalid command.")

# if __name__ == "__main__":
#     main()

"""
    Цей код створює простий інтерактивний командний рядок, який реагує на обмежений набір 
команд. Ми реалізували цикл запит-відповідь, який буде служити відмінною основою для 
додавання функціональності в майбутніх домашніх завданнях.
    Тепер додамо парсер команд. Перепишемо наш код наступним чином """

# def parse_input(user_input):
#     cmd, *args = user_input.split()
#     cmd = cmd.strip().lower()
#     return cmd, *args

# def main():
#     print("Welcome to the assistant bot!")
#     while True:
#         user_input = input("Enter a command: ")
#         command, *args = parse_input(user_input)

#         if command in ["close", "exit"]:
#             print("Good bye!")
#             break

#         elif command == "hello":
#             print("How can I help you?")
#         else:
#             print("Invalid command.")

# if __name__ == "__main__":
#     main()
                      
"""
    Ми додали функцію parse_input(user_input) яка приймає рядок вводу користувача user_
input і розбиває його на слова за допомогою методу split(). Вона повертає перше слово як 
команду cmd та решту як список аргументів *args. Рядок коду cmd, *args = user_input.split()
розділяє рядок на слова. Перше слово зберігається у змінній cmd, а решта зберігається у 
списку args завдяки оператору розпакування *. Далі рядок коду cmd = cmd.strip().lower() 
видаляє зайві пробіли навколо команди та перетворює її на нижній регістр.
        
        ☝ Навіщо приводити команду до нижнього регістру?
        Припустимо, користувач вводить команду як "HELLO", "Hello" або "hello". Якщо не 
        привести ці варіанти до спільного регістру, вони будуть розглядатися як різні
        команди, і вам доведеться обробляти кожний варіант окремо.

    Приведення команди до нижнього регістру дозволяє уникнути цього, перетворюючи всі 
варіанти на однакову форму. Таким чином, ви можете легко порівнювати введену команду з 
попередньо визначеними командами без зважання на те, як користувач ввів її.
    Це забезпечує кращий досвід користувача, оскільки програма стає менш чутливою до 
конкретного способу введення команд.
    Отриманий результат в функції main ми отримаємо після виконання рядка коду command, 
    *args = parse_input(user_input) .
    Функція parse_input розбиває введений рядок на слова, використовуючи пробіл як 
розділювач. Змінна command отримує перше значення та вважається командою, а змінна args 
стає списком з усіх інших значень.
    Наприклад якщо ми введемо команду "add John 123456" то змінна command стане рядком 
"add" а змінна args стане списком ["John", "123456"] . Якщо ж ми введемо команду 
"hello" то command стане рядком "hello", а args буде пустим списком []
    Маємо надію, ви вже зрозуміли тепер принцип парсера, настав час додати команду add."""

# def parse_input(user_input):
#     cmd, *args = user_input.split()
#     cmd = cmd.strip().lower()
#     return cmd, *args

# def add_contact(args, contacts):
#     name, phone = args
#     contacts[name] = phone
#     return "Contact added."

# def main():
#     contacts = {}
#     print("Welcome to the assistant bot!")
#     while True:
#         user_input = input("Enter a command: ")
#         command, *args = parse_input(user_input)

#         if command in ["close", "exit"]:
#             print("Good bye!")
#             break
#         elif command == "hello":
#             print("How can I help you?")
#         elif command == "add":
#             print(add_contact(args, contacts))
#         else:
#             print("Invalid command.")

# if __name__ == "__main__":
#     main()

"""
    Ми додали словник з контактами contacts = {} всередину функції main та функцію-обробник 
команди add_contact.
    Функція add_contact призначена для додавання нового контакту до словника контактів. 
Вона приймає два аргументи: args, який є списком і містить ім'я та телефонний номер, та 
contacts, який є словником, де зберігаються контакти.
    Всередині функції, два елементи зі списку args розпаковуються в змінні name та phone. 
Функція далі додає пару ключ-значення до словника контактів, використовуючи ім'я як ключ і 
телефонний номер як значення contacts[name] = phone.

        ☝ Треба зауважити, що, якщо контакт з таким ім'ям вже існує, його дані будуть 
        перезаписані без будь-яких попереджень. Тут ви вже можете діяти на свій розсуд, 
        хочете чи ні ви обробляти колізію, в нашому варіанті ми перезаписуємо контакт.
    Функція add_contact повертає рядок, що підтверджує успішне додавання контакту: 
"Contact added.".
    Необхідно зауважити, що ця функція не має вбудованих перевірок на помилки введення. 
Наприклад, якщо args не містить двох елементів, ця функція викличе помилку ValueError.

ValueError: not enough values to unpack (expected 2, got 0)

    Обробку помилок в цьому домашньому завданні залиште на свій розсуд, бо в наступному 
домашньому завданні ми додамо обробку помилок через декоратори.
                        
                        Критерії оцінювання:

    - Бот повинен перебувати в нескінченному циклі, чекаючи команди користувача.
    - Бот завершує свою роботу, якщо зустрічає слова: "close" або "exit".
    - Бот не чутливий до регістру введених команд.
    - Бот приймає команди:
    - "hello", та відповідає у консоль повідомленням "How can I help you?"
    - "add username phone". За цією командою бот зберігає у пам'яті, наприклад у словнику, 
    новий контакт. Користувач вводить ім'я username та номер телефону phone, обов'язково 
    через пробіл.
    - "change username phone". За цією командою бот зберігає в пам'яті новий номер телефону 
    phone для контакту username, що вже існує в записнику.
    - "phone username" За цією командою бот виводить у консоль номер телефону для 
    зазначеного контакту username.
    - "all". За цією командою бот виводить всі збереженні контакти з номерами телефонів у 
    консоль.
    - "close", "exit" за будь-якою з цих команд бот завершує свою роботу після того, як 
    виведе у консоль повідомлення "Good bye!" та завершить своє виконання.
    - Логіка команд реалізована в окремих функціях і ці функції приймають на вхід один або 
    декілька рядків та повертають рядок.
    - Вся логіка взаємодії з користувачем реалізована у функції main, всі print та input 
    відбуваються тільки там.


    Зауваживши вищеописане, напишемо фінальний варіант коду.
"""

def parse_input(user_input):
    """ Функція для розбору введеного користувачем рядка на команду та аргументи.
    Параметри:
    user_input (str): Рядок, введений користувачем, який містить команду та аргументи.
    Повертає:
    tuple: Кортеж, що містить команду (str) та список аргументів (str)."""
    # Розбиваємо введений рядок на слова та видаляємо зайві пробіли
    cmd, *args = user_input.split()
    # Перетворюємо команду на нижній регістр для уніфікації
    cmd = cmd.strip().lower()
    # Повертаємо команду та аргументи
    return cmd, *args

def add_contact(args, contacts):
    """ Функція для додавання нового контакту до словника контактів.
    Параметри:
    args (list): Список, що містить ім'я та номер телефону.
    contacts (dict): Словник, де зберігаються контакти.
    Повертає:
    str: Повідомлення про успішне додавання контакту."""
    # Перевіряємо, чи передано правильну кількість аргументів
    if len(args) != 2:
        # Якщо аргументів не два, повертаємо повідомлення про помилку
        return "Invalid command. Usage: add username phone"
    # Розпаковуємо аргументи в змінні name та phone
    name, phone = args
    contacts[name] = phone
    return "Contact added."
    
def change_contact(args, contacts):
    """ Функція для зміни номера телефону існуючого контакту.
    Параметри:
    args (list): Список, що містить ім'я та новий номер телефону.
    contacts (dict): Словник, де зберігаються контакти.
    Повертає:
    str: Повідомлення про успішне оновлення контакту або про помилку."""
    # Перевіряємо, чи передано правильну кількість аргументів
    if len(args) != 2:
        # Якщо аргументів не два, повертаємо повідомлення про помилку
        return "Invalid command. Usage: change username phone"
    # Розпаковуємо аргументи в змінні name та phone
    name, phone = args
    # Перевіряємо, чи існує контакт з таким ім'ям
    if name in contacts:
        # Якщо контакт існує, оновлюємо його номер телефону
        contacts[name] = phone
        # повертаємо повідомлення про успішне оновлення контакту
        return "Contact updated."
    else:
        # Якщо контакт не існує, повертаємо повідомлення про помилку
        return f"Contact '{name}' not found."

def show_phone(args, contacts):
    """ Функція для показу номера телефону за ім'ям контакту.
    Параметри:
    args (list): Список, що містить ім'я контакту.
    contacts (dict): Словник, де зберігаються контакти.
    Повертає:
    str: Номер телефону контакту або повідомлення про помилку, якщо контакт не знайдено."""
    # Перевіряємо, чи передано правильну кількість аргументів
    if len(args) != 1:
        # Якщо аргументів не один, повертаємо повідомлення про помилку
        return "Invalid command. Usage: phone username"
    # Розпаковуємо аргумент в змінну name
    name = args[0]
    # Перевіряємо, чи існує контакт з таким ім'ям
    if name in contacts:
        # Якщо контакт існує, повертаємо його номер телефону
        return f"{name}'s phone number is {contacts[name]}."
    else:
        # Якщо контакт не існує, повертаємо повідомлення про помилку
        return f"Contact '{name}' not found."

def show_all(contacts):
    """ Функція для показу всіх контактів та їх номерів телефонів.
    Параметри:
    contacts (dict): Словник, де зберігаються контакти.
    Повертає:
    str: Список всіх контактів з номерами телефонів або повідомлення, якщо контакти відсутні.
    """
    # Перевіряємо, чи є контакти в словнику
    if not contacts:
        # Якщо словник порожній, повертаємо повідомлення про відсутність контактів
        return "No contacts found."
    # Форматуємо рядок з усіма контактами
    return "\n".join([f"{name}: {phone}" for name, phone in contacts.items()])

def main():
    """ Основна функція, яка запускає бот-помічник та обробляє команди користувача.
    Вона містить нескінченний цикл, який чекає на введення команди користувачем та
    виконує відповідні дії в залежності від введеної команди."""
    # Ініціалізуємо словник для зберігання контактів
    contacts = {}
    # Виводимо привітальне повідомлення
    print("Welcome to the assistant bot!")
    # Починаємо нескінченний цикл для обробки команд
    while True:
        # Отримуємо введення користувача
        user_input = input("Enter a command: ")
        # Розбираємо введення користувача на команду та аргументи
        command, *args = parse_input(user_input)
        # Перевіряємо, чи команда є однією з команд для завершення роботи
        if command in ["close", "exit"]:
            # Якщо команда є "close" або "exit", виводимо прощальне повідомлення 
            # та завершуємо роботу
            print("Good bye!")
            break
        elif command == "hello":
            # Якщо команда є "hello", виводимо повідомлення про допомогу
            # та запитуємо, як можемо допомогти
            print("How can I help you?")
        elif command == "add":
            # Якщо команда є "add", викликаємо функцію для додавання контакту
            # та передаємо аргументи та словник контактів
            print(add_contact(args, contacts))
        elif command == "change":
            # Якщо команда є "change", викликаємо функцію для зміни контакту
            # та передаємо аргументи та словник контактів
            print(change_contact(args, contacts))
        elif command == "phone":
            # Якщо команда є "phone", викликаємо функцію для показу номера телефону
            # та передаємо аргументи та словник контактів
            print(show_phone(args, contacts))
        elif command == "all":
            # Якщо команда є "all", викликаємо функцію для показу всіх контактів
            # та передаємо словник контактів
            print(show_all(contacts))
        else:
            # Якщо команда не розпізнана, виводимо повідомлення про невірну команду
            # та запитуємо ввести правильну команду (йдемо на початок циклу)
            print("Invalid command.")
if __name__ == "__main__":
    main()
